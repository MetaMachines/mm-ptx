#!/usr/bin/env python3
"""
Generate a C header for PTX inject data types from a JSON spec, with optional
helper functions emitted to a separate header.

Uses only the Python standard library.

Examples:

# 1) Main header
python ptx_inject_generate_infos.py \
  --in types.json \
  --out ptx_inject_data_types.h

You can adjust names/prefixes with CLI flags; run -h for details.
"""

import argparse
import json
import os
import re
import sys
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional

def die(msg: str, code: int = 2):
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(code)

def load_json(path: str) -> Dict[str, Any]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        die(f"input file not found: {path}")
    except json.JSONDecodeError as e:
        die(f"invalid JSON in {path}: {e}")

def sanitize_identifier(s: str) -> str:
    s2 = re.sub(r'[^0-9a-zA-Z]', '_', s)
    s2 = re.sub(r'_+', '_', s2).strip('_')
    if not s2:
        s2 = "X"
    if s2[0].isdigit():
        s2 = "_" + s2
    return s2

def make_enum_item(prefix: str, name: str) -> str:
    base = sanitize_identifier(name).upper()
    return f"{prefix}_{base}"

def c_char_literal(s: str) -> str:
    if not s:
        return "'r'"
    ch = s[0]
    if ch == "'":
        return "'\\''"
    if ch == '\\':
        return "'\\\\'"
    if 32 <= ord(ch) <= 126 and ch not in ["\\", "'"]:
        return f"'{ch}'"
    return f"(char){ord(ch)}"

def dedupe_keep_order(seq: List[str]) -> List[str]:
    seen = set()
    out = []
    for x in seq:
        if x not in seen:
            seen.add(x)
            out.append(x)
    return out

def gen_stamp() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

def build_enum_and_array(
    spec: Dict[str, Any],
    enum_prefix: str,
    array_name: str,
    count_name: str,
    enum_name: str,
    indent: str = "    ",
):
    dti = spec.get("data_type_infos")
    if not isinstance(dti, list) or not dti:
        die("spec.data_type_infos must be a non-empty list")

    required_keys = ["name", "register_type", "mov_postfix", "register_char", "register_cast_str"]
    for i, item in enumerate(dti):
        if not isinstance(item, dict):
            die(f"data_type_infos[{i}] must be an object")
        missing = [k for k in required_keys if k not in item]
        if missing:
            die(f"data_type_infos[{i}] missing keys: {', '.join(missing)}")
        for k in required_keys:
            if not isinstance(item[k], str):
                die(f"data_type_infos[{i}].{k} must be a string")

    enum_items = [make_enum_item(enum_prefix, item["name"]) for item in dti]
    enum_items = dedupe_keep_order(enum_items)
    num_enums_sym = f"{enum_prefix}_NUM_ENUMS"

    array_lines = []
    array_lines.append("//  name,       register_type,  mov_postfix,    register_char,  register_cast_str")
    for item in dti:
        name = item["name"]
        reg_type = item["register_type"]
        mov_postfix = item["mov_postfix"]
        reg_char = c_char_literal(item["register_char"])
        cast_str = item["register_cast_str"]
        array_lines.append(
            f'{indent}{{ "{name}", "{reg_type}", "{mov_postfix}", {reg_char}, "{cast_str}" }},'
        )

    to_string_cases = []
    for item in dti:
        ei = make_enum_item(enum_prefix, item["name"])
        to_string_cases.append(f"{indent*2}case {ei}:      return \"{item['name']}\";")
    to_string_cases.append(f"{indent*2}case {num_enums_sym}: break;")

    return enum_items, num_enums_sym, array_lines, to_string_cases

def generate_main_header(
    *,
    spec: Dict[str, Any],
    in_json_path: str,
    header_name: str,
    enum_name: str,
    enum_prefix: str,
    array_name: str,
    count_name: str,
    to_string_name: str,
    indent: str = "    ",
) -> str:

    enum_items, num_enums_sym, array_lines, to_string_cases = build_enum_and_array(
        spec, enum_prefix, array_name, count_name, enum_name, indent
    )

    default_includes = [
        "<ptx_inject.h>",
    ]
    final_includes = dedupe_keep_order(default_includes)

    abi_version = spec.get("abi_version", None)
    abi_block = ""
    if isinstance(abi_version, int):
        abi_block = (
            "\n"
            "#ifdef PTX_INJECT_TYPES_ABI_VERSION\n"
            f"#if PTX_INJECT_TYPES_ABI_VERSION != {abi_version}\n"
            '#error "PTX_INJECT_TYPES_ABI_VERSION mismatch with generated header"\n'
            "#endif\n"
            "#endif\n"
        )

    pieces = []
    pieces.append(f"// Auto-generated by ptx_inject_generate_infos.py on {gen_stamp()}")
    pieces.append(f"// Source JSON: {os.path.basename(in_json_path)}")
    pieces.append("#pragma once")
    pieces.append("")
    pieces.extend([f"#include {inc}" for inc in final_includes])
    pieces.append(abi_block)

    # Enum
    pieces.append(f"typedef enum {{")
    for ei in enum_items:
        pieces.append(f"{indent}{ei},")
    pieces.append(f"{indent}{num_enums_sym}")
    pieces.append(f"}} {enum_name};")
    pieces.append("")

    # Array
    pieces.append(f"static const PtxInjectDataTypeInfo {array_name}[] = {{")
    pieces.append("\n".join(array_lines))
    pieces.append("};")
    pieces.append(
        f"static const size_t {count_name} = PTX_INJECT_ARRAY_NUM_ELEMS({array_name});"
    )
    pieces.append("")

    # to_string
    pieces.append(
        f"__attribute__((unused))\nstatic\nconst char*\n{to_string_name}(\n"
        f"{indent}{enum_name} data_type\n"
        f") {{\n"
        f"{indent}switch(data_type) {{\n"
        + "\n".join(to_string_cases) + "\n"
        f"{indent}}}\n"
        f"{indent}return \"invalid_data_type\";\n"
        f"}}\n"
    )

    return "\n".join(pieces).replace("\n\n\n", "\n\n")

def main():
    ap = argparse.ArgumentParser(description="Generate C header(s) from PTX inject JSON spec.")
    ap.add_argument("--in", dest="in_json", required=True, help="Path to input JSON.")
    ap.add_argument("--out", dest="out_hdr", required=True, help="Path to output .h file.")
    ap.add_argument("--enum-name", default="PtxInjectDataType", help="C enum typedef name.")
    ap.add_argument("--enum-prefix", default="PTX_INJECT_DATA_TYPE",
                    help="Enum value prefix (e.g., PTX_INJECT_DATA_TYPE).")
    ap.add_argument("--array-name", default="ptx_inject_data_type_infos",
                    help="Name of the generated PtxInjectDataTypeInfo array.")
    ap.add_argument("--count-name", default="num_ptx_inject_data_type_infos",
                    help="Name of the generated count symbol.")
    ap.add_argument("--to-string-name", default="ptx_inject_data_type_to_string",
                    help="Name of the data-type to-string function.")

    args = ap.parse_args()

    spec = load_json(args.in_json)

    # Derive guards if not supplied
    def default_guard(path: str) -> str:
        base = os.path.basename(path)
        return sanitize_identifier(base).upper() + "_INCLUDE"

    # MAIN HEADER
    hdr_txt = generate_main_header(
        spec=spec,
        in_json_path=args.in_json,
        header_name=args.out_hdr,
        enum_name=args.enum_name,
        enum_prefix=args.enum_prefix,
        array_name=args.array_name,
        count_name=args.count_name,
        to_string_name=args.to_string_name,
    )
    os.makedirs(os.path.dirname(os.path.abspath(args.out_hdr)) or ".", exist_ok=True)
    with open(args.out_hdr, "w", encoding="utf-8") as f:
        f.write(hdr_txt)
    print(f"Wrote: {args.out_hdr}")

if __name__ == "__main__":
    main()
