# Stack PTX

## Overview

Stack PTX is a single-file header-only C library that takes a sequence of instructions and outputs PTX that reflects these instructions being run in a stack machine. The language was heavily inspired by Professor Lee Spector's [push](https://faculty.hampshire.edu/lspector/push.html) language and systems.

The library has no dependencies other than the standard C libraries and the library is C99 compliant. Similar to the [stb single-header libraries](https://github.com/nothings/stb), `stack_ptx.h` serves as both header and implementation. As such `STACK_PTX_IMPLEMENTATION` should be defined before the `stack_ptx.h` include in only one compilation unit. Like so:
``` c
#define STACK_PTX_IMPLEMENTATION
#include <stack_ptx.h>
```
Adding `STACK_PTX_DEBUG` turns every error returned in the library in to an assert at the site that is easy to debug. Like so:
``` c
#define STACK_PTX_DEBUG
#define STACK_PTX_IMPLEMENTATION
#include <stack_ptx.h>
```

Each function in this library returns an error code that should be checked (just like the cuda apis). A `stackPtxCheck` macro is provided for convenience.

A separate header file `stack_ptx_generated_descriptions.h` contains descriptions for PTX assembly instructions that are compatible with Stack PTX. 
This file is generated by the python script `stack_ptx_description_generator.py` from the CSV files `descriptions/ptx_instructions.csv` and `descriptions/special_registers.csv`. This file is also a single-file header-only C library that is both a header and source file. As such `STACK_PTX_DEFS_IMPLEMENTATION` should be defined before the `stack_ptx_generated_descriptions.h` include in only one compilations unit. Like so:
``` c
#define STACK_PTX_DEFS_IMPLEMENTATION
#include <stack_ptx_generated_descriptions.h>
```
You should be able to easily edit the CSV files to add, remove or customize the PTX instructions that Stack PTX has access to. You can generate a new `stack_ptx_generated_descriptions.h` with:
``` bash
python tools/stack_ptx_description_generator.py descriptions/ptx_instructions.csv descriptions/special_registers.csv stack_ptx_generated_descriptions.h
```

## Motivation

The motivation for this api is to allow easy creation of valid ptx code. For example in PTX you might write:
``` c
mul.ftz.f32 %f0, 1.0, 2.0
add.ftz.f32 %f1, %f0, 0.2;
```
With Stack PTX you'd express this like:
``` c
[ stack_ptx_encode_constant_f32(1.0), 
  stack_ptx_encode_constant_f32(2.0), 
  stack_ptx_encode_ptx_instruction_mul_ftz_f32, 
  stack_ptx_encode_constant_f32(0.2),
  stack_ptx_encode_ptx_instruction_add_ftz_f32,
  stack_ptx_encode_return
]
```
In the above example
* `stack_ptx_encode_constant_f32(1.0)` means 1.0 goes on the stack
* `stack_ptx_encode_constant_f32(2.0)` means 2.0 goes on the stack
* `stack_ptx_encode_ptx_instruction_mul_ftz_f32` means that the top two float values are popped from the stack and used as operands for multiply. If the stack doesn't contain two values, the operation is skipped. Since 1.0 and 2.0 are on the stack, the operation is successful and an AST value representing the result is pushed on to the stack.
* `stack_ptx_encode_constant_f32(0.2)` means 0.2 goes on the stack
* `stack_ptx_encode_ptx_instruction_add_ftz_f32` means that the top two float values are popped from the stack and used as operands for add. One of the operand values is 0.2 the other is the AST value representing the multiply operation from earlier.

The fact that this is represented by stack operations means any operation can be deleted, inserted or swapped at any place and you'll still have a valid series of ptx instructions. The Stack PTX compiler implements dead code elimination on the AST so operations that aren't relevant to the requested stack values don't show up in the generated ptx.

When the above code runs, assuming there is one request for a f32 stack value for a register named "output_register", the PTX emitted looks like:
```
  {
  .reg .f32 %_a<2>;
  mul.ftz.f32 %_a0, 0f40000000, 0f3F800000;
  add.ftz.f32 %_a1, 0f3E4CCCCD, %_a0;
  mov.f32 %output_register, %_a1;
  }
```

Additionally the PTX generation in this system is extremely fast, given 100 instructions or so the system can output valid PTX in single digit **microseconds**.

Stack PTX code **can** be written by humans, but it is much better 

## Examples

- **Stack PTX only**
  - ðŸ“š Overview: [examples/stack_ptx/README.md](examples/stack_ptx/README.md)
  - âœ… Quickstart (simplest): [examples/stack_ptx/00_simple/main.c](examples/stack_ptx/00_simple/main.c)

- **PTX Inject**
  - ðŸ“– Readme / concepts: [PTX_INJECT.md](PTX_INJECT.md)

- **Combined (Stack PTX + PTX Inject)**
  - ðŸ”— Integrated examples: [examples/stack_ptx_inject/README.md](examples/stack_ptx_inject/README.md)

- **Python Bindings for Stack PTX + PTX Inject + Examples**
    - https://github.com/MetaMachines/mm-ptx-py
    
- **PyTorch Customizable Hyperparameter Semirings**
  - https://github.com/MetaMachines/mm-kermac-py

## Tutorial / Explanation

### Stacks
  As the name Stack PTX implies Stack PTX uses stack data structures to store intermediate data while executing instructions and storing updates to it's AST while compiling. Instructions can push data on to stacks or pop data from stacks or do both.

### The Interface
Stack PTX exposes three functions:
* **`stack_ptx_result_to_string`**: Just returns the string representation of a `StackPtxResult`.
* **`stack_ptx_compile_workspace_size`**: Gives the user the amount of memory `stack_ptx_compile` will need to compile it's programs. This factors in various settings such as the number of stacks, the depth of each stack, the maximum number of elements to be stored in the AST, etc..
* **`stack_ptx_compile`**: This is the workhorse of the Stack PTX system. The most important function parameters are `instructions`, `registers` and `requests`.

## Instructions
Stack PTX mostly relies on the `StackPtxInstruction` struct to descibe what to do with the list of instructions. This struct is designed to be fixed size at **8 bytes** or **64 bits**. Most data related to the compilation for the instruction is stored in these 8 bytes except for the string representations that end up in PTX code, such as "add.ftz.f32", "mul.ftz.f32", etc..

The instructions are fixed size to make it easy to shuffle instruction lists around or assemble them on the fly or delete random elements out of the array without breaking anything. You should be able to randomly throw any set of instructions in the array of instructions and expect back valid PTX assembly code.

### Return
---
Return is the simplest instruction. It's just a sentinel value signaling the end of execution for an array of instructions avoiding the need to pass a length to the `stack_ptx_compile` routine. It may be encoded with:
```
stack_ptx_encode_return
```
The instruction lists in [mm-ptx-py](https://github.com/MetaMachines/mm-ptx-py) don't need this instruction as it's automatically appended just before compiling.

### Constants
---
The simplest instruction that actually does something is the constant instruction which just pushes a constant value to the relevant stack. The constant the user declares is limited to 32 bits in size. This is because the constant is stored inside the instruction itself. The macros in for example `generated_headers/stack_ptx_default_generated_types.h` look like:
```C
stack_ptx_encode_constant_f32(1.0f)
stack_ptx_encode_constant_u32(10)
```
Those instructions would push `1.0f` to the `f32` stack and `10` to the `u32` stack.

### Meta Instructions
---
Meta Instructions are inspired from the [Push](https://faculty.hampshire.edu/lspector/push.html) language by Prof [Lee Spector](https://faculty.hampshire.edu/lspector/). These instructions are meant to manipulate the Stacks during construction of the AST before the AST is compiled to PTX code. They perform various operations on their relevant stacks. If not enough values are present on the relevant stack or in the case of an indexed instruction, `meta_stack` is empty, the meta instruction is ignored. If an indexed meta instruction pops a value off of the `meta_stack` and it's too deep the instruction is also ignored.

A runnable example for meta instructions is [examples/stack_ptx/03_meta_instructions](examples/stack_ptx/03_meta_instructions).
#### Meta `constant`
---
This instruction just pushes an integer on to the special `meta_stack` to be used by other meta instructions that might require an integer as an input.
```C
stack_ptx_encode_meta_constant(2)
```
#### Meta `dup`
---
This instruction duplicates the top value of the relevant stack.
```C
stack_ptx_encode_meta_dup(STACK_PTX_STACK_TYPE_F32)
```
Would duplicate a value on the `F32` stack so there are now two of them at the top of the stack.
#### Meta `yank_dup`
---
This instruction does the same as `dup` but pops an integer value off of the `meta_stack` to use for a depth parameter. It reaches that amount of depth into the relevant stack and duplicates that value to the top of the same stack leaving the original value untouched.
```C
stack_ptx_encode_meta_yank_dup(STACK_PTX_STACK_TYPE_F32)
```
#### Meta `swap`
---
This instruction takes the top two values of the relevant stack and swaps them.
```C
stack_ptx_encode_meta_swap(STACK_PTX_STACK_TYPE_U32)
```
#### Meta `swap_with`
---
This instruction is the same as `swap` but pops an integer value off of the `meta_stack` to use for a depth parameter. It reaches that amount of depth into the relevant stack and swaps it with the current value at the top of the stack.
```C
stack_ptx_encode_meta_swap_with(STACK_PTX_STACK_TYPE_U32)
```
#### Meta `replace`
---
This instructions is similar to `swap_with` it also pops an integer value off of the `meta_stack` to use as a depth parameter. However, instead of swapping it with the value of the top of the stack, it is replaced with the value at the top of the stack.
```C
stack_ptx_encode_meta_replace(STACK_PTX_STACK_TYPE_U32)
```
#### Meta `drop`
---
This instruction reads an integer value from the `meta_stack` and drops that many elements from the relevant stack.
```C
stack_ptx_encode_meta_drop(STACK_PTX_STACK_TYPE_U32)
```
#### Meta `rotate`
---
This instruction takes the element at the top of the stack and moves it two deep. `abc` becomes `bca`.
```C
stack_ptx_encode_meta_rotate(STACK_PTX_STACK_TYPE_U32)
```
#### Meta `reverse`
---
This instruction takes a given stack and reverses the order of the stack. `abcd` becomes `dcba`.
```C
stack_ptx_encode_meta_reverse(STACK_PTX_STACK_TYPE_U32)
```

### Inputs
Inputs are meant to push externally declared PTX registers on to the relevant stack. They require an index to identify them. This index is used to access their string register name passed in to `stack_ptx_compile` through the `const StackPtxRegister* 	registers` parameter. `StackPtxRegister` contains the registers string name and it's stack type. The index used to encode the Input StackPtxInstruction type is used to access that input's register data. For example:
```C
stack_ptx_encode_input(0),
stack_ptx_encode_input(2)
```
When the above instructions are run the instructions will grab theirregister information from element 0 and element 2 of the `StackPtxRegister registers` array. It's common to use **enums** to maintain consistent naming for these indices. See [`examples/stack_ptx/00_simple/main.c`](examples/stack_ptx/00_simple/main.c).

### Ptx Instruction
Stack PTX PTX instruction encode the actual PTX instructions that will be encoding in the output PTX from running `stack_ptx_compile`. They're still **8 bytes** long, their payload contains all the information for which stacks to pop from and which stacks to push to. You can see how this is setup in [`type_descriptions/stack_ptx_desciptions.json`](type_descriptions/stack_ptx_descriptions.json). Each instruction can contain up to 4 input arguments and output up to 2 returns, per the [`PTX ISA`](https://docs.nvidia.com/cuda/parallel-thread-execution/) spec. These instructions can be encoded like:
```C
stack_ptx_encode_ptx_instruction_add_u32,
stack_ptx_encode_ptx_instruction_mul_ftz_f32
```
From the descriptions `json` file you can see that `stack_ptx_encode_ptx_instruction_add_u32` reads two values from the `U32` stack and pushes one value back to the `U32` stack. `stack_ptx_encode_ptx_instruction_mul_ftz_f32` reads two values from the `F32` stack and pushes one value back to the `F32` stack.

The instructions can get more complex because the values that describe their arg types aren't just stack types, they're arg types which can represent 4xF32 values respresented as vectors in PTX using braces like `{%a0, %a1, %a2, %a3}`. For example the `V4_F32` arg type means that whenever it's value is requested, the instruction should read 4 values from the `F32` stack. If used as a return it should push it's 4 vector elements to the `F32` stack. See [`examples/stack_ptx/06_mma/main.c`](examples/stack_ptx/06_mma/main.c) for an example using a tensor core instruction and [`examples/stack_ptx_inject/03_mma_sync`](examples/stack_ptx_inject/03_mma_sync) which runs an example using a tensor core instruction.

### Special Registers
Stack PTX Special Register instructions are similar to Stack PTX PTX Instructions in that they use arg types to describe their behavior. They exist to encode Special Register strings from the PTX ISA in to PTX. In [`type_descriptions/stack_ptx_desciptions.json`](type_descriptions/stack_ptx_descriptions.json) you can also see a section that describes the `special_registers`. For example `tid.x` will push it's value to the `U32` stack. `tid` will push it's 4 values to the `U32` stack because it uses the arg_type `V4_U32`. You will then find `tid.x`, `tid.y`, `tid.z` and `tid.w` in the output PTX representing the equivalent of `threadIdx.x`, `threadIdx.y`, etc.. in CUDA code. See [`examples/stack_ptx/04_special_registers/main.c`](examples/stack_ptx/04_special_registers/main.c).
```C
stack_ptx_encode_special_register_tid_x,
stack_ptx_encode_special_register_tid
```
### Store/Load
Stack PTX Store and Load instructions are meant to manipulate the stack to store values from it to be used later. This can greatly help human programmers encode their intended behavior for Stack PTX. When `store` is run the value of the requested stack is popped and the index `store` is ran with is the location in a load/store array that the value is put at. Running `load` for the same index causes the value to reappear on the stack. `load` can be called multiple times to cause the same value to be pushed to the stack multiple times. If load for an index is run which never was stored to, the instruction is ignored.
```C
stack_ptx_encode_store(STACK_PTX_STACK_TYPE_F32, 0)
stack_ptx_encode_load(0)
```
For an example see [`examples/stack_ptx/07_store_load`](examples/stack_ptx/07_store_load).

## Routines
Routines are passed into `stack_ptx_compile` as a parameter. Each routine in the `routines` array is another array of instructions similar to the `instructions` passed in to `stack_ptx_compile`. Routines allow an instruction in the `instructions` array to call another set of instructions for the given routine index. Routines can even call other routines. The struct `StackPtxCompilerInfo`contains a parameter called `max_frame_depth` which sets the maximum depth of routines calling other routines before returning. Similar to the instructions array, each routine must be terminated by a `return` instruction with `stack_ptx_encode_return`.
```C
stack_ptx_encode_routine(0)
```
For examples see:
* [`examples/stack_ptx/01_routines`](examples/stack_ptx/01_routines)
* [`examples/stack_ptx/02_routine_libraries`](examples/stack_ptx/02_routine_libraries)

## Requests
Requests are passed in to `stack_ptx_compile` as a parameter. Whereas `input` instructions allow external registers to appear as arguments in Stack PTX generated PTX assembly. Requests allow external registers to be set **by** instructions in Stack PTX generated PTX.

Each request represents an index in the `const StackPtxRegister* 	registers` array. For each `request` in the `requests` array the relevant stack information is looked up from the `registers` array. The stack value associated with that `request` is popped and a `mov` instruction is generated setting the internal Stack PTX register to the string value of the external register.

# Custom Types
Stack PTX is designed to be unaware of Stack types and Arg types and specific PTX instructions, etc.. Stack PTX works primarily off of tables passed in to it to generate PTX assembly. This allows the user to customize their setup as they wish. 

The default types used by the `examples` is at [`type_descriptions/stack_ptx_descriptions.json`](type_descriptions/stack_ptx_descriptions.json). A very simple description is at [`type_descriptions/stack_ptx_simple.json`](type_descriptions/stack_ptx_simple.json).

To regenerate the [`generated_headers/stack_ptx_default_generated_types.h`](generated_headers/stack_ptx_default_generated_types.h) you can use the python script:
```bash
python ~/mm-ptx/tools/stack_ptx_generate_infos.py --input ~/mm-ptx/type_descriptions/stack_ptx_des
    criptions.json --output ~/mm-ptx/generated_headers/stack_ptx_default_generated_types.h --lang c
```
This script will declare all the encoding macros for Stack PTX using the given types.

# C++
This project is written in C but is compliant with C++. All you need to change is to generate the C++ version of the generated headers instead of the C version. The C version makes use of macros and designated initializers to be able to declare `static const StackPtxInstruction[] = { .. };`. To generate the C++ headers specify `--lang cpp` instead of `--lang c`:
```bash
python ~/mm-ptx/tools/stack_ptx_generate_infos.py --input ~/mm-ptx/type_descriptions/stack_ptx_des
    criptions.json --output ~/mm-ptx/generated_headers/stack_ptx_default_generated_types.hpp --lang cpp
```
This will generate the cpp equivalent to the c generated header. It uses `constexpr` to be able to do `static const StackPtxInstruction[] = { .. };`. It also includes convenient namespaces and enums.