# Stack PTX

## Overview

Stack PTX is a single-file header-only C library that takes a sequence of instructions and outputs PTX that reflects these instructions being run in a stack machine. The language was heavily inspired by Professor Lee Spector's [push](https://faculty.hampshire.edu/lspector/push.html) language and systems.

The library has no dependencies other than the standard C libraries and the library is C99 compliant. Similar to the [stb single-header libraries](https://github.com/nothings/stb), `stack_ptx.h` serves as both header and implementation. As such `STACK_PTX_IMPLEMENTATION` should be defined before the `stack_ptx.h` include in only one compilation unit. Like so:
``` c
#define STACK_PTX_IMPLEMENTATION
#include <stack_ptx.h>
```
Adding `STACK_PTX_DEBUG` turns every error returned in the library in to an assert at the site that is easy to debug. Like so:
``` c
#define STACK_PTX_DEBUG
#define STACK_PTX_IMPLEMENTATION
#include <stack_ptx.h>
```

Each function in this library returns an error code that should be checked (just like the cuda apis). A `stackPtxCheck` macro is provided for convenience.

A separate header file `stack_ptx_generated_descriptions.h` contains descriptions for PTX assembly instructions that are compatible with Stack PTX. 
This file is generated by the python script `stack_ptx_description_generator.py` from the CSV files `descriptions/ptx_instructions.csv` and `descriptions/special_registers.csv`. This file is also a single-file header-only C library that is both a header and source file. As such `STACK_PTX_DEFS_IMPLEMENTATION` should be defined before the `stack_ptx_generated_descriptions.h` include in only one compilations unit. Like so:
``` c
#define STACK_PTX_DEFS_IMPLEMENTATION
#include <stack_ptx_generated_descriptions.h>
```
You should be able to easily edit the CSV files to add, remove or customize the PTX instructions that Stack PTX has access to. You can generate a new `stack_ptx_generated_descriptions.h` with:
``` bash
python tools/stack_ptx_description_generator.py descriptions/ptx_instructions.csv descriptions/special_registers.csv stack_ptx_generated_descriptions.h
```

## Motivation

The motivation for this api is to allow easy creation of valid ptx code. For example in PTX you might write:
``` c
mul.ftz.f32 %f0, 1.0, 2.0
add.ftz.f32 %f1, %f0, 0.2;
```
With Stack PTX you'd express this like:
``` c
[ stack_ptx_encode_constant_f32(1.0), 
  stack_ptx_encode_constant_f32(2.0), 
  stack_ptx_encode_ptx_instruction_mul_ftz_f32, 
  stack_ptx_encode_constant_f32(0.2),
  stack_ptx_encode_ptx_instruction_add_ftz_f32,
  stack_ptx_encode_return
]
```
In the above example
* `stack_ptx_encode_constant_f32(1.0)` means 1.0 goes on the stack
* `stack_ptx_encode_constant_f32(2.0)` means 2.0 goes on the stack
* `stack_ptx_encode_ptx_instruction_mul_ftz_f32` means that the top two float values are popped from the stack and used as operands for multiply. If the stack doesn't contain two values, the operation is skipped. Since 1.0 and 2.0 are on the stack, the operation is successful and an AST value representing the result is pushed on to the stack.
* `stack_ptx_encode_constant_f32(0.2)` means 0.2 goes on the stack
* `stack_ptx_encode_ptx_instruction_add_ftz_f32` means that the top two float values are popped from the stack and used as operands for add. One of the operand values is 0.2 the other is the AST value representing the multiply operation from earlier.

The fact that this is represented by stack operations means any operation can be deleted, inserted or swapped at any place and you'll still have a valid series of ptx instructions. The Stack PTX compiler implements dead code elimination on the AST so operations that aren't relevant to the requested stack values don't show up in the generated ptx.

When the above code runs, assuming there is one request for a f32 stack value for a register named "output_register", the PTX emitted looks like:
```
  {
  .reg .f32 %_a<2>;
  mul.ftz.f32 %_a0, 0f40000000, 0f3F800000;
  add.ftz.f32 %_a1, 0f3E4CCCCD, %_a0;
  mov.f32 %output_register, %_a1;
  }
```

Additionally the PTX generation in this system is extremely fast, given 100 instructions or so the system can output valid PTX in single digit **microseconds**.

Stack PTX code **can** be written by humans, but it is much better 

## Examples

- **Stack PTX only**
  - ðŸ“š Overview: [examples/stack_ptx/README.md](examples/stack_ptx/README.md)
  - âœ… Quickstart (simplest): [examples/stack_ptx/00_simple/main.c](examples/stack_ptx/00_simple/main.c)

- **PTX Inject**
  - ðŸ“– Readme / concepts: [PTX_INJECT.md](PTX_INJECT.md)

- **Combined (Stack PTX + PTX Inject)**
  - ðŸ”— Integrated examples: [examples/stack_ptx_inject/README.md](examples/stack_ptx_inject/README.md)

- **Python Bindings for Stack PTX + PTX Inject + Examples**
    - https://github.com/MetaMachines/mm-ptx-py
    
- **PyTorch Customizable Hyperparameter Semirings**
  - https://github.com/MetaMachines/mm-kermac-py

## Tutorial / Explanation

### The Interface
### Return Instruction
### Constants
### Meta Instructions
### Special Registers
### Inputs
### Requests
### Routines
### Store/Load
